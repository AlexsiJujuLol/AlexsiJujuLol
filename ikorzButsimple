local player = game:GetService("Players").LocalPlayer

local function isWhitelisted(userId)
    for _, id in ipairs(whitelistedUserIds) do
        if userId == id then
            return true
        end
    end
    return false
end

if not isWhitelisted(player.UserId) then
    player:Kick("Not whitelisted.")
end

if _G.NiggaNiggaNiggaNiggaNiggaSkiddedSlidentAhhFuckMe == true then return end
wait()
_G.NiggaNiggaNiggaNiggaNiggaSkiddedSlidentAhhFuckMe = true
repeat wait() until game:IsLoaded()
local Stats = game:GetService("Stats")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local speedFactorPingBased
local speedFactor
local Nurysium_Util = loadstring(game:HttpGet("https://raw.githubusercontent.com/flezzpe/Nurysium/main/nurysium_helper.lua"))()
local function getTrainingBall()
	for index, ball in workspace:WaitForChild("TrainingBalls"):GetChildren() do
		if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
			return ball
		end
	end
end
local ismyautoparryspamming
local local_player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local standalone = false
print("-----------------")
print("nigga code by ikorz skid bu frost)
print("-----------------")

--//OPTIONS

local originalParryRemote
local originalResolveParryRemote 
local aivar, visualizervar, autospamvar, autoparryvar, tphitvar, autowinvar
local nurysium_Data = nil
local hit_Sound = nil
local closest_Entity = nil
local parry_remote = nil
local aura_Enabled = false
local auto_curve = false
local hit_sound_Enabled = false
local auto_spam = false
local training_mode = false
local hit_effect_Enabled = false
local anti_curve_spam_Enabled = false
local visualize_Enabled = false
local ai_Enabled = false
local auto_win = false
local tp_hit = false
local night_mode_Enabled = false
local spectate_Enabled = false
local trail_Enabled = false
local auto_rewards_enabled = false
local potanum = 15
local Services = {
    game:GetService('AnimationFromVideoCreatorService'),
    game:GetService('AdService')
}

function initializate(dataFolder_name: string)
    local nurysium_Data = Instance.new('Folder', game:GetService('CoreGui'))
    nurysium_Data.Name = dataFolder_name

    hit_Sound = Instance.new('Sound', nurysium_Data)
    hit_Sound.SoundId = 'rbxassetid://6607204501'
    hit_Sound.Volume = 6
end

local function get_closest_entity(Object)
	task.spawn(function()
		local closest
		local max_distance = math.huge
		for index, entity in workspace.Alive:GetChildren() do
			if entity.Name ~= Players.LocalPlayer.Name then
				local distance = (Object.Position - entity.HumanoidRootPart.Position).Magnitude
				if distance < max_distance then
					closest_Entity = entity
					max_distance = distance
				end
			end
		end
		return closest_Entity
	end)
end
function resolve_parry_Remote()
        for _, v in pairs(Services) do
            local temp_remote = v:FindFirstChildOfClass('RemoteEvent')
    
            if temp_remote and temp_remote.Name:find('\n') then
            originalParryRemote = temp_remote
        end
    end
end

resolve_parry_Remote()

function walk_to(position)
	local_player.Character.Humanoid:MoveTo(position)
end
local function get_center()
	for _, object in workspace.Map:GetDescendants() do
		if object.Name == 'BALLSPAWN' then
			return object
		end
	end
end

local aura_table = {
	canParry = true,
	is_Spamming = false,
	parry_Range = 30,
	spam_Range = 0,  
	hit_Count = 0,
	hit_Time = tick(),
	ball_Warping = tick(),
	is_ball_Warping = false,
	last_target = nil,
}

workspace:WaitForChild("Balls").ChildRemoved:Connect(function(child)
	aura_table.hit_Count = 0
	aura_table.is_ball_Warping = false
	aura_table.is_Spamming = false
	aura_table.canParry = true
	aura_table.last_target = nil
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function()
	aura_table.hit_Count += 1

	task.delay(0.185, function()
		aura_table.hit_Count -= 1
	end)
end)

-- Call resolve_parry_Remote once to initialize the originalParryRemote

--start, the real one

local MauaulSpam -- Declare MauaulSpam globally

function ManualSpam()
    -- Gui to Lua
    -- Version: 3.2
    
    if MauaulSpam then
        MauaulSpam:Destroy()
        MauaulSpam = nil
        return
    end

    MauaulSpam = Instance.new("ScreenGui")
    MauaulSpam.Name = "MauaulSpam"
    MauaulSpam.Parent = game.CoreGui
    MauaulSpam.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    MauaulSpam.ResetOnSpawn = false

    local Main = Instance.new("Frame")
    Main.Name = "Main"
    Main.Parent = MauaulSpam
    Main.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Main.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Main.BorderSizePixel = 0
    Main.Position = UDim2.new(0.41414836, 0, 0.404336721, 0)
    Main.Size = UDim2.new(0.227479532, 0, 0.191326529, 0)

    local UICorner = Instance.new("UICorner")
    UICorner.Parent = Main

    local IndercantorBlahblah = Instance.new("Frame")
    IndercantorBlahblah.Name = "IndercantorBlahblah"
    IndercantorBlahblah.Parent = Main
    IndercantorBlahblah.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    IndercantorBlahblah.BorderColor3 = Color3.fromRGB(0, 0, 0)
    IndercantorBlahblah.BorderSizePixel = 0
    IndercantorBlahblah.Position = UDim2.new(0.0280000009, 0, 0.0733333305, 0)
    IndercantorBlahblah.Size = UDim2.new(0.0719999969, 0, 0.119999997, 0)

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.CornerRadius = UDim.new(1, 0)
    UICorner_2.Parent = IndercantorBlahblah

    local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint.Parent = IndercantorBlahblah

    local PC = Instance.new("TextLabel")
    PC.Name = "PC"
    PC.Parent = Main
    PC.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    PC.BackgroundTransparency = 1.000
    PC.BorderColor3 = Color3.fromRGB(0, 0, 0)
    PC.BorderSizePixel = 0
    PC.Position = UDim2.new(0.547999978, 0, 0.826666653, 0)
    PC.Size = UDim2.new(0.451999992, 0, 0.173333332, 0)
    PC.Font = Enum.Font.Unknown
    PC.Text = "PC: E to spam"
    PC.TextColor3 = Color3.fromRGB(57, 57, 57)
    PC.TextScaled = true
    PC.TextSize = 16.000
    PC.TextWrapped = true

    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint.Parent = PC
    UITextSizeConstraint.MaxTextSize = 16

    local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_2.Parent = PC
    UIAspectRatioConstraint_2.AspectRatio = 4.346

    local IndercanotTextBlah = Instance.new("TextButton")
    IndercanotTextBlah.Name = "IndercanotTextBlah"
    IndercanotTextBlah.Parent = Main
    IndercanotTextBlah.Active = false
    IndercanotTextBlah.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    IndercanotTextBlah.BackgroundTransparency = 1.000
    IndercanotTextBlah.BorderColor3 = Color3.fromRGB(0, 0, 0)
    IndercanotTextBlah.BorderSizePixel = 0
    IndercanotTextBlah.Position = UDim2.new(0.164000005, 0, 0.326666653, 0)
    IndercanotTextBlah.Selectable = false
    IndercanotTextBlah.Size = UDim2.new(0.667999983, 0, 0.346666664, 0)
    IndercanotTextBlah.Font = Enum.Font.GothamBold
    IndercanotTextBlah.Text = "OFF"
    IndercanotTextBlah.TextColor3 = Color3.fromRGB(255, 255, 255)
    IndercanotTextBlah.TextScaled = true
    IndercanotTextBlah.TextSize = 24.000
    IndercanotTextBlah.TextWrapped = true

    local UIGradient = Instance.new("UIGradient")
    UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 4)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))}
    UIGradient.Parent = IndercanotTextBlah

    local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
    UITextSizeConstraint_2.Parent = IndercanotTextBlah
    UITextSizeConstraint_2.MaxTextSize = 52

    local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_3.Parent = IndercanotTextBlah
    UIAspectRatioConstraint_3.AspectRatio = 3.212

    local UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint")
    UIAspectRatioConstraint_4.Parent = Main
    UIAspectRatioConstraint_4.AspectRatio = 1.667

--Properties:

MauaulSpam.Name = "MauaulSpam"
MauaulSpam.Parent = game.CoreGui
MauaulSpam.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
MauaulSpam.ResetOnSpawn = false

Main.Name = "Main"
Main.Parent = MauaulSpam
Main.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Main.BorderColor3 = Color3.fromRGB(0, 0, 0)
Main.BorderSizePixel = 0
Main.Position = UDim2.new(0.41414836, 0, 0.404336721, 0)
Main.Size = UDim2.new(0.227479532, 0, 0.191326529, 0)

UICorner.Parent = Main

IndercantorBlahblah.Name = "IndercantorBlahblah"
IndercantorBlahblah.Parent = Main
IndercantorBlahblah.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
IndercantorBlahblah.BorderColor3 = Color3.fromRGB(0, 0, 0)
IndercantorBlahblah.BorderSizePixel = 0
IndercantorBlahblah.Position = UDim2.new(0.0280000009, 0, 0.0733333305, 0)
IndercantorBlahblah.Size = UDim2.new(0.0719999969, 0, 0.119999997, 0)

UICorner_2.CornerRadius = UDim.new(1, 0)
UICorner_2.Parent = IndercantorBlahblah

UIAspectRatioConstraint.Parent = IndercantorBlahblah

PC.Name = "PC"
PC.Parent = Main
PC.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PC.BackgroundTransparency = 1.000
PC.BorderColor3 = Color3.fromRGB(0, 0, 0)
PC.BorderSizePixel = 0
PC.Position = UDim2.new(0.547999978, 0, 0.826666653, 0)
PC.Size = UDim2.new(0.451999992, 0, 0.173333332, 0)
PC.Font = Enum.Font.Unknown
PC.Text = "PC: E to spam"
PC.TextColor3 = Color3.fromRGB(57, 57, 57)
PC.TextScaled = true
PC.TextSize = 16.000
PC.TextWrapped = true

UITextSizeConstraint.Parent = PC
UITextSizeConstraint.MaxTextSize = 16

UIAspectRatioConstraint_2.Parent = PC
UIAspectRatioConstraint_2.AspectRatio = 4.346

IndercanotTextBlah.Name = "IndercanotTextBlah"
IndercanotTextBlah.Parent = Main
IndercanotTextBlah.Active = false
IndercanotTextBlah.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
IndercanotTextBlah.BackgroundTransparency = 1.000
IndercanotTextBlah.BorderColor3 = Color3.fromRGB(0, 0, 0)
IndercanotTextBlah.BorderSizePixel = 0
IndercanotTextBlah.Position = UDim2.new(0.164000005, 0, 0.326666653, 0)
IndercanotTextBlah.Selectable = false
IndercanotTextBlah.Size = UDim2.new(0.667999983, 0, 0.346666664, 0)
IndercanotTextBlah.Font = Enum.Font.GothamBold
IndercanotTextBlah.Text = "OFF"
IndercanotTextBlah.TextColor3 = Color3.fromRGB(255, 255, 255)
IndercanotTextBlah.TextScaled = true
IndercanotTextBlah.TextSize = 24.000
IndercanotTextBlah.TextWrapped = true

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 4)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))}
UIGradient.Parent = IndercanotTextBlah

UITextSizeConstraint_2.Parent = IndercanotTextBlah
UITextSizeConstraint_2.MaxTextSize = 52

UIAspectRatioConstraint_3.Parent = IndercanotTextBlah
UIAspectRatioConstraint_3.AspectRatio = 3.212

UIAspectRatioConstraint_4.Parent = Main
UIAspectRatioConstraint_4.AspectRatio = 1.667

-- Scripts:

local function HEUNEYP_fake_script() -- IndercanotTextBlah.ColorChangeScript 
	local script = Instance.new('LocalScript', IndercanotTextBlah)

	local button = script.Parent
	local UIGredient = button.UIGradient
	local NeedToChange = script.Parent.Parent.IndercantorBlahblah
	local userInputService = game:GetService("UserInputService")
	local RunService = game:GetService("RunService")

	-- ColorSequences ÃÆ ÃâÃÂ¸ÃâÃÂªÃÆ ÃâÃÂ¸ÃâÃÂ³ÃÆ ÃâÃÂ¸ÃâÃÂ«ÃÆ ÃâÃÂ¸ÃâÃÂ£ÃÆ ÃâÃÂ¸ÃâÃÂ±ÃÆ ÃâÃÂ¸Ãâ¦ÃÂ¡ÃÆ ÃâÃÂ¸ÃâÃÂªÃÆ ÃâÃÂ¸ÃâÃÂµÃÆ ÃâÃÂ¹ÃÂ¢Ã¢â¬Å¡ÃÂ¬ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂ¡ÃÆ ÃâÃÂ¸ÃâÃÂµÃÆ ÃâÃÂ¸ÃâÃÂ¢ÃÆ ÃâÃÂ¸ÃâÃÂ§ÃÆ ÃâÃÂ¹ÃâÃÂÃÆ ÃâÃÂ¸ÃâÃÂ¥ÃÆ ÃâÃÂ¸ÃâÃÂ°ÃÆ ÃâÃÂ¸ÃâÃÂªÃÆ ÃâÃÂ¸ÃâÃÂµÃÆ ÃâÃÂ¹ÃâÃÂÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂ¡
	local green_Color = {
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), 
		ColorSequenceKeypoint.new(0.75, Color3.fromRGB(0, 255, 0)), 
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))
	}

	local red_Color = {
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), 
		ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 0, 0)), 
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))
	}

	local current_Color = red_Color
	local target_Color = green_Color
	local is_Green = false
	local transition = false
	local transition_Time = 1
	local start_Time

	local function startColorTransition()
		transition = true
		start_Time = tick()
	end

	RunService.Heartbeat:Connect(function()
		if transition then
			local elapsed = tick() - start_Time
			local alpha = math.clamp(elapsed / transition_Time, 0, 1)

			local new_Color = {}
			for i = 1, #current_Color do
				local start_Color = current_Color[i].Value
				local end_Color = target_Color[i].Value
				new_Color[i] = ColorSequenceKeypoint.new(
					current_Color[i].Time,
					start_Color:Lerp(end_Color, alpha)
				)
			end

			UIGredient.Color = ColorSequence.new(new_Color)

			if alpha >= 1 then
				transition = false
				current_Color, target_Color = target_Color, current_Color
			end
		end
	end)

	local function toggleColor()
		if not transition then
			is_Green = not is_Green
			if is_Green then
				target_Color = green_Color
				NeedToChange.BackgroundColor3 = Color3.new(0, 1, 0)
			else
				target_Color = red_Color
				NeedToChange.BackgroundColor3 = Color3.new(1, 0, 0)
			end
			startColorTransition()
		end
	end

	button.MouseButton1Click:Connect(toggleColor)

	userInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == Enum.KeyCode.E then
			toggleColor()
		end
	end)

	local Services = {game:GetService("AdService"), game:GetService("SocialService")}
	local originalParryRemote = nil

	function resolve_parry_Remote()
        local temp_remote = game:GetService("VirtualUser"):WaitForChild("\n\n\n\n\n")
        if not temp_remote or not temp_remote:IsA('RemoteEvent') then
            return
        end
        originalParryRemote = temp_remote
    end

    resolve_parry_Remote()
    
	local camera = workspace.CurrentCamera
	local mouse = game.Players.LocalPlayer:GetMouse()

	local function getClosestEntity()
		local closest_Entity = nil
		local shortestDistance = math.huge

		for _, entity in pairs(workspace.Alive:GetChildren()) do
			if entity:IsA("Model") and entity:FindFirstChild("HumanoidRootPart") then
				local screenPoint = camera:WorldToViewportPoint(entity.HumanoidRootPart.Position)
				local distanceToMouse = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

				if distanceToMouse < shortestDistance then
					closest_Entity = entity
					shortestDistance = distanceToMouse
				end
			end
		end

		return closest_Entity
	end

	RunService.RenderStepped:Connect(function()
		if is_Green and originalParryRemote then
			local closest_Entity = getClosestEntity()
			if closest_Entity then
				local cf = camera.CFrame
				local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:GetComponents()

				originalParryRemote:FireServer(
					0,
					CFrame.new(x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22),
					{[closest_Entity.Name] = closest_Entity.HumanoidRootPart.Position},
					{closest_Entity.HumanoidRootPart.Position.X, closest_Entity.HumanoidRootPart.Position.Y},
					false
				)
			end
		end
	end)

	
	end
coroutine.wrap(HEUNEYP_fake_script)()
local function WWJM_fake_script() -- Main.LocalScript 
	local script = Instance.new('LocalScript', Main)

	local UserInputService = game:GetService("UserInputService")
	
	local gui = script.Parent
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		local newPosition = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	
		-- ÃÆ ÃâÃÂ¹Ãâ Ã¢â¬â¢ÃÆ ÃâÃÂ¸Ãâ¦ ÃÆ ÃâÃÂ¹ÃÂ¢Ã¢âÂ¬ÃÂ° Tween ÃÆ ÃâÃÂ¹ÃÂ¢Ã¢â¬Å¡ÃÂ¬ÃÆ ÃâÃÂ¸Ãâ¦ÃÂ¾ÃÆ ÃâÃÂ¸ÃâÃÂ·ÃÆ ÃâÃÂ¹Ãâ¹Ã¢â¬ ÃÆ ÃâÃÂ¸ÃâÃÂ­ÃÆ ÃâÃÂ¹Ãâ Ã¢â¬â¢ÃÆ ÃâÃÂ¸ÃâÃÂ«ÃÆ ÃâÃÂ¹ÃÂ¢Ã¢âÂ¬ÃÂ°ÃÆ ÃâÃÂ¸ÃâÃÂÃÆ ÃâÃÂ¸ÃâÃÂ²ÃÆ ÃâÃÂ¸ÃâÃÂ£ÃÆ ÃâÃÂ¹ÃÂ¢Ã¢â¬Å¡ÃÂ¬ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂ¾ÃÆ ÃâÃÂ¸ÃâÃÂ¥ÃÆ ÃâÃÂ¸ÃâÃÂ·ÃÆ ÃâÃÂ¹Ãâ¹Ã¢â¬ ÃÆ ÃâÃÂ¸ÃâÃÂ­ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢â¬Å¾ÃÂ¢ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬Ã¢â¬ÂÃÆ ÃâÃÂ¸ÃâÃÂµÃÆ ÃâÃÂ¹Ãâ¹Ã¢â¬ ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂ¡ÃÆ ÃâÃÂ¸ÃâÃÂ­ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂ¡ Frame ÃÆ ÃâÃÂ¹ÃÂ¢Ã¢â¬Å¡ÃÂ¬ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂºÃÆ ÃâÃÂ¹ÃÂ¢Ã¢âÂ¬ÃÂ¡ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢â¬Å¾ÃÂ¢ÃÆ ÃâÃÂ¹ÃÂ¢Ã¢âÂ¬ÃÂ¾ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂºÃÆ ÃâÃÂ¸ÃâÃÂ­ÃÆ ÃâÃÂ¸ÃâÃÂ¢ÃÆ ÃâÃÂ¹Ãâ¹Ã¢â¬ ÃÆ ÃâÃÂ¸ÃâÃÂ²ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢âÂ¬ÃÂ¡ÃÆ ÃâÃÂ¸ÃâÃÂ£ÃÆ ÃâÃÂ¸ÃâÃÂ²ÃÆ ÃâÃÂ¸Ãâ¦ÃÂ¡ÃÆ ÃâÃÂ¸ÃâÃÂ£ÃÆ ÃâÃÂ¸ÃâÃÂ·ÃÆ ÃâÃÂ¹Ãâ¹Ã¢â¬ ÃÆ ÃâÃÂ¸ÃÂ¢Ã¢â¬Å¾ÃÂ¢
		local TweenService = game:GetService("TweenService")
		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(gui, tweenInfo, {Position = newPosition})
		tween:Play()
	end
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			update(input)
		end
	end)
	
end
coroutine.wrap(WWJM_fake_script)()

end

local function clamp(value, min, max)
	return math.max(min, math.min(max, value))
end
local self = Nurysium_Util.getBall()
	wait(0.1)
	local Visualize = Instance.new("Part",workspace)
	local Visualize1 = Instance.new("Part",workspace)
	wait(0.5)
	Visualize.Color = Color3.new(0, 1, 0)
	Visualize.Material = Enum.Material.ForceField
	Visualize.Transparency = 0.5
	Visualize.Anchored = true
	Visualize.CanCollide = false
	Visualize.CastShadow = false
	Visualize.Shape = Enum.PartType.Ball
	Visualize.Size = Vector3.new(30,30,30)
	Visualize1.Color = Color3.new(1, 0, 0)
	Visualize1.Material = Enum.Material.ForceField
	Visualize1.Transparency = 0.5
	Visualize1.Anchored = true
	Visualize1.CanCollide = false
	Visualize1.CastShadow = false
	Visualize1.Shape = Enum.PartType.Ball
	Visualize1.Size = Vector3.new(aura_table.spam_Range, aura_table.spam_Range, aura_table.spam_Range)

	local Highlight1 = Instance.new("Highlight")
	Highlight1.Parent = Visualize1
	Highlight1.Enabled = true
	Highlight1.FillTransparency = 0
	Highlight1.OutlineColor = Color3.new(1, 1, 1)
	local Highlight = Instance.new("Highlight")
	Highlight.Parent = Visualize
	Highlight.Enabled = true
	Highlight.FillTransparency = 0
	Highlight.OutlineColor = Color3.new(1, 1, 1)
	
task.spawn(function()
	visualizervar = RunService.RenderStepped:Connect(function()
		if visualize_Enabled then
			Visualize.Transparency = 0
			Visualize.Material = Enum.Material.ForceField
			Visualize.Size = Vector3.new(aura_table.parry_Range, aura_table.parry_Range, aura_table.parry_Range)
			Visualize.CFrame = CFrame.new(local_player.Character.PrimaryPart.Position)
			Visualize1.Transparency = 0
			Visualize1.Material = Enum.Material.ForceField
			Visualize1.Size = Vector3.new(aura_table.spam_Range, aura_table.spam_Range, aura_table.spam_Range)
			Visualize1.CFrame = CFrame.new(local_player.Character.PrimaryPart.Position)
		else
			Visualize.Material = Enum.Material.ForceField
			Visualize.Transparency = 1
			Visualize1.Material = Enum.Material.ForceField
			Visualize1.Transparency = 1
		end	
	end)
end)

function getClosestEntityToMouse()
	local closest = nil
	local shortestDistance = math.huge
	local mouse = game.Players.LocalPlayer:GetMouse()

	-- Ensure workspace.Alive exists
	if not workspace:FindFirstChild("Alive") then
		return nil
	end

	-- Loop through all entities
	for _, entity in pairs(workspace.Alive:GetChildren()) do
		if entity:IsA("Model") then
			local humanoidRootPart = entity:FindFirstChild("HumanoidRootPart")
			if humanoidRootPart then
				-- Convert world position to screen position
				local screenPoint = camera:WorldToViewportPoint(humanoidRootPart.Position)
				local distanceToMouse = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

				-- Check if this is the closest entity so far
				if distanceToMouse < shortestDistance then
					closest = entity
					shortestDistance = distanceToMouse
				end
			else
				
			end
		else
			
		end
	end

	-- If no closest entity is found, warn the user
	if not closest then
		
	else
		
	end

	return closest
end

task.defer(function()
    local runService = game:GetService("RunService")
    local Players = game:GetService("Players")

    local function avoidWalls(startPos, targetPos)
        local direction = (targetPos - startPos).Unit
        local ray = Ray.new(startPos, direction * 10)
        local hit, hitPosition = workspace:FindPartOnRay(ray, local_player.Character)

        if hit then
            -- Wall detected, adjust path
            local adjustedDir = (targetPos - hitPosition).Unit + Vector3.new(0, 0, 0.5) -- Simple adjustment
            return startPos + adjustedDir * 10
        end

        return targetPos
    end

    aivar = runService.Heartbeat:Connect(function()
        if not ai_Enabled or not workspace.Alive:FindFirstChild(local_player.Name) then
            return
        end

        local self = Nurysium_Util.getBall()
        if not self or not closest_Entity then
            return
        end

        local hrp = closest_Entity:FindFirstChild('HumanoidRootPart')
        if not hrp then
            walk_to(local_player.Character.HumanoidRootPart.Position + Vector3.new(math.sin(tick()) * math.random(35, 50), 0, math.cos(tick()) * math.random(35, 50)))
            return
        end

        local tickNow = tick()
        local tickMod = tickNow % 4
        local ball_Position = self.Position
        local ball_Distance = local_player:DistanceFromCharacter(ball_Position)
        local player_Position = local_player.Character.PrimaryPart.Position
        local target_Position = hrp.Position
        local target_Distance = local_player:DistanceFromCharacter(target_Position)
        local target_LookVector = hrp.CFrame.LookVector
        local resolved_Position = Vector3.zero

        local target_Humanoid = closest_Entity:FindFirstChildOfClass("Humanoid")
        if target_Humanoid and target_Humanoid:GetState() == Enum.HumanoidStateType.Jumping and local_player.Character.Humanoid.FloorMaterial ~= Enum.Material.Air then
            local_player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        if (ball_Position - player_Position):Dot(local_player.Character.PrimaryPart.CFrame.LookVector) < -0.2 and tickMod <= 2 then
            return
        end

        -- Maintain distance or get close depending on spamming state
        if aura_table.is_Spamming then
            -- When spamming, move closer to the target
            if tickMod <= 2 then
                resolved_Position = target_Position + (player_Position - target_Position).Unit * 8
            else
                resolved_Position = target_Position - target_LookVector * (math.random(8.5, 13.5) + (ball_Distance / math.random(8, 20)))
            end
        else
            -- Avoid getting too close to other players when not spamming
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= local_player and workspace.Alive:FindFirstChild(player.Name) then
                    local otherPlayerPos = player.Character and player.Character.PrimaryPart.Position
                    if otherPlayerPos and (player_Position - otherPlayerPos).Magnitude < 10 then
                        local avoidanceVector = (player_Position - otherPlayerPos).Unit * 15
                        player_Position = player_Position + avoidanceVector
                    end
                end
            end

            -- Regular pathfinding when not spamming
            if tickMod <= 2 then
                resolved_Position = target_Distance > 10 and target_Position + (player_Position - target_Position).Unit * 25
            else
                resolved_Position = target_Position - target_LookVector * (math.random(8.5, 13.5) + (ball_Distance / math.random(8, 20)))
            end
        end

        if (player_Position - target_Position).Magnitude < 8 then
            resolved_Position = target_Position + (player_Position - target_Position).Unit * 35
        end

        if ball_Distance < 8 then
            resolved_Position = player_Position + (player_Position - ball_Position).Unit * 10
        end

        -- Avoid walls before walking
        resolved_Position = avoidWalls(player_Position, resolved_Position)

        walk_to(resolved_Position + Vector3.new(math.sin(tickNow) * 10, 0, math.cos(tickNow) * 10))
    end)
end)

task.defer(function()
	autowinvar = RunService.Stepped:Connect(function()
		if auto_win and workspace.Alive:FindFirstChild(local_player.Name) then
			local self = Nurysium_Util.getBall()
			if not self then return end
			
			local player = local_player.Character
			local ball_Position = self.Position
			local ball_Distance = (player.HumanoidRootPart.Position - ball_Position).Magnitude
			
			
			local ping = game:GetService("Stats"):FindFirstChild("PerformanceStats"):FindFirstChild("Ping"):GetValue() or 0
			local adjusted_Distance = math.clamp(15 + (ping / 50), 15, 50)

			local angle = tick() * 2
			local offset = Vector3.new(math.cos(angle) * adjusted_Distance, math.sin(angle) * 5, math.sin(angle) * adjusted_Distance)
			local target_Position = ball_Position + offset

			
			player.HumanoidRootPart.CFrame = CFrame.new(target_Position, ball_Position)
		end
	end)
	tphitvar = RunService.Heartbeat:Connect(function()
        	local self = Nurysium_Util.getBall()
	if not self or not tp_hit then return end
	local player = local_player.Character
	local ball_Position = self.Position

	if tp_hit and self:GetAttribute('target') == local_player.Name and workspace.Alive:FindFirstChild(local_player.Name) then

		local safe_Distance = 10
		local direction = (ball_Position - player.HumanoidRootPart.Position).Unit
		local target_Position = ball_Position - direction * safe_Distance

		player.HumanoidRootPart.CFrame = CFrame.new(target_Position)
	end
    end)
end)

local closest_Entity_To_mouse = nil
local Takentime = tick() - aura_table.hit_Time
RunService.Heartbeat:Connect(function()
Takentime = tick() - aura_table.hit_Time
	task.spawn(function()
		closest_Entity_To_mouse = getClosestEntityToMouse()
	end)
end)

task.spawn(function()
    autospamvar = RunService.Heartbeat:Connect(function()
        -- Pre-check if auto_spam is enabled, player exists, and not in training mode
        if not auto_spam or not workspace.Alive:FindFirstChild(local_player.Name) or training_mode then
            -- Reset aura table and spam states
            aura_table.hit_Count = 0
            aura_table.is_Spamming = false
            aura_table.last_target = nil
            ismyautoparryspamming = false
            aura_table.spam_Range = 0
            return
        end

        -- Proceed only if closest entity is valid and in workspace
        if closest_Entity and workspace.Alive:FindFirstChild(closest_Entity.Name) and ((not standalone and aura_table.is_Spamming) or (standalone)) then
            local playerPosition = local_player.Character.PrimaryPart.Position
            local entityPosition = closest_Entity.HumanoidRootPart.Position
                local distanceToEntity = local_player:DistanceFromCharacter(entityPosition)
                -- Perform spam actions only when within range
                if distanceToEntity <= aura_table.spam_Range then
                    ismyautoparryspamming = true

                    -- Pre-compute values before the loop for efficiency
                    local cf = camera.CFrame
                    local randomTarget = Vector3.new(math.random(-1000, 1000), math.random(0, 1000), math.random(100, 1000))
                    local targetPosition = closest_Entity_To_mouse.HumanoidRootPart.Position
                    local fireArgs = {
                        {[closest_Entity_To_mouse.Name] = targetPosition},
                        {targetPosition.X, targetPosition.Y}
                    }

                    -- Perform spamming asynchronously for speed using task.defer
                    task.defer(function()
                        for count = 1, potanum do
                            if auto_curve then
                                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)  
                             else
                                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001)  
                            end
                        end
                    end)
                else
                    -- Reset spam state if out of range
                    ismyautoparryspamming = false
                end
        else
            -- Reset spam state if entity is not found
            ismyautoparryspamming = false
        end
    end)

autoparryvar = RunService.Heartbeat:Connect(function()
    if not aura_Enabled or not (workspace.Alive:FindFirstChild(local_player.Name) or training_mode) then
        aura_table.hit_Time = tick() * 10
        aura_table.hit_Count = 0
        aura_table.is_ball_Warping = false
        aura_table.is_Spamming = false
        aura_table.canParry = true
        aura_table.last_target = nil
        return
    end

    local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local self

    if training_mode then
        self = getTrainingBall()
    else
        self = Nurysium_Util.getBall()
    end

    if not self then
        aura_table.hit_Time = tick() * 10
        aura_table.hit_Count = 0
        aura_table.is_ball_Warping = false
        aura_table.is_Spamming = false
        aura_table.canParry = true
        aura_table.last_target = nil
        return
    end

    self:GetAttributeChangedSignal('target'):Once(function()
        aura_table.canParry = true
    end)

    if self:GetAttribute('target') ~= local_player.Name or not aura_table.canParry then
        return
    end

    self:GetAttributeChangedSignal('from'):Once(function()
        aura_table.last_target = workspace.Alive:FindFirstChild(self:GetAttribute('from'))
    end)

    get_closest_entity(local_player.Character.PrimaryPart)

    local player_Position = local_player.Character.PrimaryPart.Position
    local ball_Position = self.Position
    local ball_Velocity = self.AssemblyLinearVelocity

    if self:FindFirstChild("zoomies") then
        ball_Velocity = self.zoomies.VectorVelocity
    end

    local ball_Direction = (local_player.Character.PrimaryPart.Position - ball_Position).Unit
    local ball_Distance = (local_player.Character.PrimaryPart.Position - ball_Position).Magnitude
    local ball_Dot = ball_Direction:Dot(ball_Velocity.Unit)
    local ball_Speed = ball_Velocity.Magnitude

    -- Anti-curve mechanism: Adjust for curving velocity
    if ball_Speed < 25 or ball_Velocity.Y > 10 then
        aura_table.hit_Time = tick() * 10
        aura_table.hit_Count = 0
        aura_table.is_ball_Warping = false
        aura_table.is_Spamming = false
        aura_table.can_parry = true
        aura_table.last_target = nil
    end

    local player_Velocity = local_player.Character.HumanoidRootPart.AssemblyLinearVelocity
    local player_isMoving = player_Velocity.Magnitude > 0
    local ball_speed_Limited = math.min(ball_Speed / 1000, 0.1)
    local ball_predicted_Distance = (ball_Distance - ping / 15.3) - (ball_Speed / 3.5)

    local targetPosition = closest_Entity_To_mouse.HumanoidRootPart.Position
    local target_Distance = local_player:DistanceFromCharacter(targetPosition)
    local closest_target_Distance = local_player:DistanceFromCharacter(closest_Entity.HumanoidRootPart.Position)
    local target_distance_Limited = math.min(target_Distance / 10000, 0.1)
    local target_Direction = (local_player.Character.PrimaryPart.Position - closest_Entity.HumanoidRootPart.Position).Unit
    local target_Velocity = closest_Entity.HumanoidRootPart.AssemblyLinearVelocity
    local target_isMoving = target_Velocity.Magnitude > 0
    local target_Dot = target_isMoving and math.max(target_Direction:Dot(target_Velocity.Unit), 0)

    aura_table.spam_Range = math.clamp(math.max(math.max(ping / 8.5, 15) + ball_Speed / 7.5, 8.4), 25, 1200)
    speedFactor = 3 - (ping / 100)
    speedFactorPingBased = 6.1 - (ping / 100)
    aura_table.parry_Range = math.max(math.max(ping, 3.5) + ball_Speed / speedFactor, speedFactorPingBased)

    if target_isMoving then
        aura_table.is_Spamming = aura_table.hit_Count > 1 or (target_Distance <= aura_table.spam_Range and ball_Distance < 18 and ball_Speed > 8) and ball_Velocity.Y > -50 and ball_Dot > 0.15
    else
        aura_table.is_Spamming = aura_table.hit_Count > 1 or (target_Distance <= aura_table.spam_Range and ball_Distance < 18 and ball_Speed > 8) and ball_Velocity.Y > -50 and ball_Dot > 0.15
    end

    local velocity_angle = math.abs(math.acos(ball_Direction:Dot(ball_Velocity.Unit)))

    if ball_Dot < -0.2 then
        aura_table.ball_Warping = tick()
    end

    task.spawn(function()
        if (tick() - aura_table.ball_Warping) >= 0.15 + target_distance_Limited - ball_speed_Limited or ball_Distance <= 10 then
            aura_table.is_ball_Warping = false
            return
        end

        if aura_table.last_target then
            if (ball_Position - aura_table.last_target.HumanoidRootPart.Position).Magnitude > 35.5 or target_Distance <= 12 then
                aura_table.is_ball_Warping = false
            end
        end

        aura_table.is_ball_Warping = true
    end)

    if ball_Distance <= aura_table.parry_Range and not aura_table.is_ball_Warping and ball_Speed > 0 and ball_Dot > 0.1 then
        local cf = camera.CFrame
        local target_X = targetPosition.X
        local target_Y = targetPosition.Y

        if auto_curve then
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)  
        else
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001)  
        end

        aura_table.hit_Count = aura_table.hit_Count + 1
        task.delay(0.55 + (ping / 100), function()
            aura_table.hit_Count = aura_table.hit_Count - 1
        end)

        aura_table.hit_Time = tick()
        aura_table.canParry = false
    end

    task.spawn(function()
        repeat
            RunService.PreRender:Wait()
        until (tick() - aura_table.hit_Time) >= 1
        aura_table.canParry = true
    end)
end)
end)
-- Define a safe disconnect function to avoid errors
local function safeDisconnect(connection)
    if connection and connection.Disconnect then
        connection:Disconnect()
    end
end

-- Function to manage connections
local function manageConnection(flag, varName, runServiceFunc)
    if flag then
        if not _G[varName] then
            -- Create the RunService connection if the flag is true and connection is not already created
            _G[varName] = RunService[runServiceFunc]:Connect(function()
                -- Your code for what the connection does
            end)
        end
    else
        -- Disconnect and clear the connection if the flag is false
        safeDisconnect(_G[varName])
        _G[varName] = nil
    end
end

-- Main loop running on Heartbeat
RunService.Heartbeat:Connect(function()
    manageConnection(visualize_Enabled, "visualizervar", "Heartbeat")
    manageConnection(auto_spam, "autospamvar", "Heartbeat")
    manageConnection(aura_Enabled, "autoparryvar", "Heartbeat")
    manageConnection(tp_hit, "tphitvar", "Heartbeat")
    manageConnection(auto_win, "autowinvar", "Heartbeat")
    manageConnection(ai_Enabled, "aivar", "RenderStepped")
end)

--//night mode, trail, Spectate Scripts here

--//Night Mode
task.defer(function()
    while task.wait(1) do
        if night_mode_Enabled then
            TweenService:Create(game:GetService("Lighting"), TweenInfo.new(3), {ClockTime = 1.9}):Play()
        else
            TweenService:Create(game:GetService("Lighting"), TweenInfo.new(3), {ClockTime = 13.5}):Play()
        end
    end
end)

--//Trail 
task.defer(function()
    game:GetService("RunService").Heartbeat:Connect(function()

        if not local_player.Character then
            return
        end

        if trail_Enabled then
            local trail = game:GetObjects("rbxassetid://17483658369")[1]

            trail.Name = 'nurysium_fx'

            if local_player.Character.PrimaryPart:FindFirstChild('nurysium_fx') then
                return
            end

            local Attachment0 = Instance.new("Attachment", local_player.Character.PrimaryPart)
            local Attachment1 = Instance.new("Attachment", local_player.Character.PrimaryPart)

            Attachment0.Position = Vector3.new(0, -2.411, 0)
            Attachment1.Position = Vector3.new(0, 2.504, 0)

            trail.Parent = local_player.Character.PrimaryPart
            trail.Attachment0 = Attachment0
            trail.Attachment1 = Attachment1
        else

            if local_player.Character.PrimaryPart:FindFirstChild('nurysium_fx') then
                local_player.Character.PrimaryPart['nurysium_fx']:Destroy()
            end
        end

    end)
end)

--//Spectate 
task.defer(function()
    RunService.RenderStepped:Connect(function()
        if spectate_Enabled then

            local self = Nurysium_Util.getBall()

            if not self then
                return
            end

            workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(CFrame.new(workspace.CurrentCamera.CFrame.Position, self.Position), 1.5)
        end
    end)
end)

local isFPSBoosterEnabled = false  -- Status awal FPS booster

local function enableFPSBooster()
    -- Mengatur kualitas grafis ke tingkat terendah
    settings().Rendering.QualityLevel = Enum.QualityLevel.Level01

    -- Menghapus objek visual berlebihan di Workspace
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
            obj.Enabled = false  -- Nonaktifkan semua efek partikel
        elseif obj:IsA("Decal") or obj:IsA("Texture") then
            obj:Destroy()  -- Hapus semua tekstur dan decal
        elseif obj:IsA("BasePart") and (obj.Material == Enum.Material.Grass or obj.Material == Enum.Material.LeafyGrass) then
            obj.Transparency = 1  -- Sembunyikan objek berumput atau berdaun
        end
    end

    -- Pengaturan pencahayaan ekstrem untuk meningkatkan FPS
    local Lighting = game:GetService("Lighting")
    Lighting.GlobalShadows = false
    Lighting.Brightness = 0  -- Atur kecerahan serendah mungkin
    Lighting.ClockTime = 12  -- Mengatur waktu ke siang hari
    Lighting.FogEnd = 9e9  -- Menghapus efek kabut
    Lighting.EnvironmentDiffuseScale = 0
    Lighting.EnvironmentSpecularScale = 0
    Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)  -- Mengurangi kontras untuk performa

    -- Menghapus aksesori dan kosmetik dari karakter pemain
    local player = game.Players.LocalPlayer
    player.CharacterAdded:Connect(function(character)
        for _, accessory in pairs(character:GetChildren()) do
            if accessory:IsA("Accessory") or accessory:IsA("Clothing") or accessory:IsA("ShirtGraphic") then
                accessory:Destroy()  -- Hapus semua aksesori dan pakaian
            end
        end
    end)
end

local function disableFPSBooster()
    -- Mengembalikan kualitas grafis ke otomatis
    settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic

    -- Mengaktifkan kembali efek visual dan detail di Workspace
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
            obj.Enabled = true  -- Aktifkan semua efek partikel kembali
        elseif obj:IsA("BasePart") and (obj.Material == Enum.Material.Grass or obj.Material == Enum.Material.LeafyGrass) then
            obj.Transparency = 0  -- Tampilkan objek berumput atau berdaun kembali
        end
    end

    -- Mengembalikan pengaturan pencahayaan ke default
    local Lighting = game:GetService("Lighting")
    Lighting.GlobalShadows = true
    Lighting.Brightness = 2
    Lighting.ClockTime = 14
    Lighting.FogEnd = 1000
    Lighting.EnvironmentDiffuseScale = 1
    Lighting.EnvironmentSpecularScale = 1
    Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)  -- Mengembalikan warna normal

    -- Mengembalikan pakaian dan aksesori (jika script pengembalian tersedia)
end

-- Variabel kontrol untuk chams
local isChamsEnabled = false
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local chamColor = Color3.fromRGB(0, 255, 0)  -- Warna hijau
local chamTransparency = 0.5

-- Fungsi untuk menambahkan atau menghapus Chams
local function toggleChams(enable)
    isChamsEnabled = enable
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, part in ipairs(player.Character:GetChildren()) do
                if part:IsA("BasePart") then
                    if enable then
                        -- Menambahkan Chams
                        if not part:FindFirstChild("Chams") then
                            local chams = Instance.new("BoxHandleAdornment")
                            chams.Name = "Chams"
                            chams.Adornee = part
                            chams.Color3 = chamColor
                            chams.Transparency = chamTransparency
                            chams.Size = part.Size + Vector3.new(0.1, 0.1, 0.1)
                            chams.ZIndex = 10
                            chams.AlwaysOnTop = true
                            chams.Parent = part
                        end
                    else
                        -- Menghapus Chams
                        local chams = part:FindFirstChild("Chams")
                        if chams then
                            chams:Destroy()
                        end
                    end
                end
            end
        end
    end
end

-- Menambahkan event untuk pemain yang baru bergabung
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if isChamsEnabled then
            toggleChams(true) -- Tambahkan chams jika toggle dalam keadaan aktif
        end
    end)
end)


ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if hit_sound_Enabled then
        hit_Sound:Play()
    end

    if hit_effect_Enabled then
        local hit_effect = game:GetObjects("rbxassetid://17407244385")[1]

        hit_effect.Parent = Nurysium_Util.getBall()
        hit_effect:Emit(3)

        task.delay(5, function()
            hit_effect:Destroy()
        end)

    end
end)


local function get_character()
    return LocalPlayer and LocalPlayer.Character
end

local function get_humanoid_root_part()
    local char = get_character()
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function get_humanoid()
    local char = get_character()
    return char and char:FindFirstChild("Humanoid")
end

local function get_ball()
    local ballContainer = Workspace:FindFirstChild("Balls")
    if ballContainer then
        for _, ball in ipairs(ballContainer:GetChildren()) do
            if not ball.Anchored then
                return ball
            end
        end
    end
    return nil
end

local function calculate_parry_distance()
    local ball = get_ball()
    if ball then
        local ping = LocalPlayer:GetNetworkPing() * 20
        return math.clamp(ball.Velocity.Magnitude / 2.4 + ping, 15, 200)
    end
    return 15
end

local function create_circle_visualizer()
    -- Create the visualizer part
    local visualizer = Instance.new("Part")
    visualizer.Size = Vector3.new(7, 7, 7) -- Set size to 5,5,5
    visualizer.Shape = Enum.PartType.Ball -- Make it a sphere
    visualizer.Anchored = true -- Anchor it so it doesn't fall
    visualizer.CanCollide = false -- Disable collision
    visualizer.Material = Enum.Material.ForceField -- Make it neon for better visibility
    visualizer.Color = Visualise2color -- Set its color
    visualizer.Transparency = 0.5 -- Slight transparency
    visualizer.Parent = workspace -- Add to the game world

    return visualizer
end

-- Toggle handling
local visualizerPart = nil
local function toggle_visualizer()
    if Visualise2 then
        if not visualizerPart then
            visualizerPart = create_circle_visualizer()
        end
    else
        if visualizerPart then
            visualizerPart:Destroy()
            visualizerPart = nil
        end
    end
end

-- Update the visualizer position
RunService.Heartbeat:Connect(function()
    if Visualise2 and visualizerPart then
        local humanoidRootPart = get_humanoid_root_part()
        if humanoidRootPart then
            visualizerPart.Position = humanoidRootPart.Position
        end
    end
end)

-- Example toggle (for testing, you can replace this with a keybind toggle)
RunService.RenderStepped:Connect(function()
    toggle_visualizer()
end)
            
-- Visualizer Settings
-- Visualizer Logic
local sphere

local function create_visualizer()
    if sphere then return end -- Avoid duplicating the sphere

    sphere = Instance.new("Part")
    sphere.Shape = Enum.PartType.Ball
    sphere.Anchored = true
    sphere.CanCollide = false
    sphere.CastShadow = false
    sphere.Transparency = 1 -- Hidden by default
    sphere.Material = Enum.Material.ForceField
    sphere.Parent = Workspace
end

local function update_visualizer()
    if not visualise then
        if sphere then
            sphere.Transparency = 1
        end
        return
    end

    local humanoidRootPart = get_humanoid_root_part()
    if not humanoidRootPart then
        if sphere then
            sphere.Transparency = 1
        end
        return
    end

    local parryDistance = calculate_parry_distance()
    if sphere then
        sphere.Transparency = 0.5
        sphere.Size = Vector3.new(parryDistance * 2, parryDistance * 2, parryDistance * 2)
        sphere.Position = humanoidRootPart.Position
        sphere.Color = VisualiseColor
    end
end

-- Ball Velocity Toggle
            -- Toggle for displaying Ball Velocity

local function update_ball_velocity_display(ball, velocityText)
    if not BallVelocity then
        velocityText.Text = ""
        return
    end

    if ball then
        local velocity = ball.Velocity.Magnitude
        velocityText.Text = string.format("Ball Velocity: %.2f", velocity)
    end
end

local function create_ball_velocity_display(ball)
    -- Check if the display already exists
    local existingDisplay = ball:FindFirstChild("BallVelocityDisplay")
    if existingDisplay then
        return existingDisplay
    end

    -- Create the BillboardGui for the velocity display
    local ballVelocityDisplay = Instance.new("BillboardGui")
    ballVelocityDisplay.Name = "BallVelocityDisplay"
    ballVelocityDisplay.Adornee = ball
    ballVelocityDisplay.Size = UDim2.new(0, 200, 0, 50)
    ballVelocityDisplay.StudsOffset = Vector3.new(0, 5, 0) -- Position above the ball
    ballVelocityDisplay.Parent = ball

    -- Create the text label
    local velocityText = Instance.new("TextLabel")
    velocityText.Size = UDim2.new(1, 0, 1, 0)
    velocityText.BackgroundTransparency = 1
    velocityText.TextColor3 = Color3.new(1, 1, 1) -- White text
    velocityText.TextSize = 18
    velocityText.Text = ""
    velocityText.Parent = ballVelocityDisplay

    return velocityText
end

-- Monitor and update ball velocity
local lastBall
RunService.RenderStepped:Connect(function()
    if not BallVelocity then
        if lastBall and lastBall:FindFirstChild("BallVelocityDisplay") then
            lastBall.BallVelocityDisplay:Destroy()
        end
        lastBall = nil
        return
    end

    local ball = get_ball()
    if ball ~= lastBall then
        -- Clear the previous display
        if lastBall and lastBall:FindFirstChild("BallVelocityDisplay") then
            lastBall.BallVelocityDisplay:Destroy()
        end

        -- Create a new display for the current ball
        if ball then
            local velocityText = create_ball_velocity_display(ball)
            lastBall = ball

            -- Update the text periodically
            RunService.RenderStepped:Connect(function()
                if ball and velocityText then
                    update_ball_velocity_display(ball, velocityText)
                end
            end)
        end
    end
end)

-- Autofarm Logic

local function autofarm()
    if not AutoFarm then return end

    local ball = get_ball()
    local humanoidRootPart = get_humanoid_root_part()
    if not ball or not humanoidRootPart then return end

    local position = ball.Position
    if AutoFarmType == "UnderBall" then
        humanoidRootPart.CFrame = CFrame.new(position - Vector3.new(0, 10, 0))
    elseif AutoFarmType == "X Orbit" then
        local angle = tick() * math.pi * 2 / (AutoFarmOrbit / 5)
        humanoidRootPart.CFrame = CFrame.new(position + Vector3.new(math.cos(angle) * 10, 0, math.sin(angle) * 10))
    elseif AutoFarmType == "Y Orbit" then
        local angle = tick() * math.pi * 2 / (AutoFarmOrbit / 5)
        humanoidRootPart.CFrame = CFrame.new(position + Vector3.new(0, math.sin(angle) * 10, math.cos(angle) * 10))
    end
end

-- AI Play Logic

local function ai_play()
    if not AiPlay then return end

    local ball = get_ball()
    local humanoidRootPart = get_humanoid_root_part()
    local humanoid = get_humanoid()
    if not ball or not humanoidRootPart or not humanoid then return end

    local ballPosition = ball.Position
    local playerPosition = humanoidRootPart.Position
    local distance = (ballPosition - playerPosition).Magnitude

    if distance <= 20 then
        humanoid:Move(Vector3.zero)
        return
    end

    local direction = (ballPosition - playerPosition).Unit
    local targetPosition = playerPosition + direction * math.min(distance - 20, AiPlaySpeed / 10)

    if AiPlayType == "Legit" then
        humanoid.WalkSpeed = 35
    elseif AiPlayType == "Hacker" then
        humanoid.WalkSpeed = AiPlaySpeed
    end

    humanoid:MoveTo(targetPosition)
end

-- Main Loops
RunService.RenderStepped:Connect(function()
    update_visualizer()
    autofarm()
    ai_play()
end)

-- Initialize the visualizer
create_visualizer()


task.defer(function()
    while task.wait(1) do
        if Nightmode then
            TweenService:Create(game:GetService("Lighting"), TweenInfo.new(3), {ClockTime = 1.9}):Play()
        else
            TweenService:Create(game:GetService("Lighting"), TweenInfo.new(3), {ClockTime = 13.5}):Play()
        end
    end
end)

task.defer(function()
    while task.wait(1) do
        if ShadersEffect then
            -- Apply shader effects
            TweenService:Create(game:GetService("Lighting").Bloom, TweenInfo.new(4), {
                Size = 150,
                Intensity = 2.5
            }):Play()
            TweenService:Create(game:GetService("Lighting").ColorCorrection, TweenInfo.new(4), {
                Saturation = 0.3,
                Contrast = 0.2,
                Brightness = 0.1
            }):Play()
            TweenService:Create(game:GetService("Lighting").DepthOfField, TweenInfo.new(4), {
                FocusDistance = 30,
                InFocusRadius = 15,
                NearIntensity = 0.7,
                FarIntensity = 0.7
            }):Play()

            -- Update Lighting properties
            game.Lighting.GlobalShadows = true
            game.Lighting.Ambient = Color3.fromRGB(100, 100, 100)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(80, 80, 80)
            game:GetService("Lighting").Bloom.Enabled = true
            game:GetService("Lighting").ColorCorrection.Enabled = true
            game:GetService("Lighting").DepthOfField.Enabled = true
        else
            -- Reset shader effects
            game.Lighting.GlobalShadows = false
            game.Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            game:GetService("Lighting").Bloom.Enabled = false
            game:GetService("Lighting").ColorCorrection.Enabled = false
            game:GetService("Lighting").DepthOfField.Enabled = false
        end
    end
end)



local function GetSpamTarget()
    local SpamTarget = nil
    local MaxDistance = math.huge

    for _, target in pairs(workspace.Alive:GetChildren()) do
        if target:IsA("Model") and target.Name ~= plr.Name then
            local distance = (plr.Character.HumanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude

            if distance < MaxDistance then
                SpamTarget = target
                MaxDistance = distance
            end
        end
    end

    return SpamTarget
end

local function spam()
    while getgenv().CanSpam do
        VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
        wait(spamspeed)
    end
end

spawn(function()
    rs.PreRender:Connect(function()
        if not getgenv().AutoSpam then return end

        local STarget = GetSpamTarget()
        if STarget and STarget:FindFirstChild("Humanoid") and STarget.Humanoid.Health > 0 then
            local distance = (plr.Character.HumanoidRootPart.Position - STarget.HumanoidRootPart.Position).Magnitude
            if distance <= getgenv().SpamDistance and not getgenv().CanSpam then
                getgenv().CanSpam = true
                spawn(spam)
            else
                getgenv().CanSpam = false
            end
        end
    end)
end)

local function get_plr()
  return game.Players.LocalPlayer
end

local function get_plrChar()
  local plrChar = get_plr().Character
  if plrChar then
    return plrChar
  end
end

local function get_plrRP()
  local plrRP = get_plrChar():FindFirstChild("HumanoidRootPart")
  if plrRP then
    return plrRP
  end
end

local function playerJump()
  pcall(function()
    game.Players.LocalPlayer.Character.Humanoid.Jump = true
  end)
end

local function get_PlayersNumber()
  local Alive = workspace:WaitForChild("Alive", 20):GetChildren()
  local PlayersNumber = 0
  for _,v in pairs(Alive) do
    if v and v:FindFirstChild("Humanoid") and v.Humanoid.Health > 50 then
      PlayersNumber = PlayersNumber + 1
    end
  end
  return PlayersNumber
end

local function get_ProxyPlayer()
  local Players = workspace:WaitForChild("Alive"):GetChildren()
  local Distance = math.huge
  local plr = game.Players.LocalPlayer
  local plrRP = plr.Character:FindFirstChild("HumanoidRootPart")
  local Player = nil
  
  for _,plr1 in pairs(Players) do
    if plr1.Name ~= plr.Name and plrRP and plr1:FindFirstChild("HumanoidRootPart") and plr1:FindFirstChild("Humanoid") and plr1.Humanoid.Health > 50 then
      local magnitude = (plr1.HumanoidRootPart.Position - plrRP.Position).Magnitude
      if magnitude <= Distance then
        Distance = magnitude
        Player = plr1
      end
    end
  end
  return Player
end

local function Click_Button()
  task.spawn(function()
    local VirtualInputManager = game:GetService("VirtualInputManager")
                            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)  
                            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001)                          
       warn("Spamming using key kemote")
  end)
end

task.spawn(function()
  while task.wait() do
    if getgenv().SpamClickA then
      Click_Button()
    end
  end
end)

local function DetectSpam()
  local Balls = workspace:WaitForChild("Balls", 20)
  
  local OldPos = Vector3.new()
  local OldTick1 = tick()
  
  local OldBall = Balls
  local TargetPlayer = ""
  local SpamNum = 0
  local BallSpeed = 0
  local BallDistance = 0
  
  task.spawn(function()
    local OldTick = tick()
    local OldPos = Vector3.new()
    while getgenv().DetectSpam do task.wait()
      local plrRP = get_plrRP()
      local Ball = Balls:FindFirstChildOfClass("Part")
      if plrRP and Ball then
        BallDistance = (plrRP.Position - Ball.Position).Magnitude
        BallSpeed = (OldPos - Ball.Position).Magnitude
        if tick() - OldTick >= 1/60 then
          OldTick = tick()
          OldPos = Ball.Position
        end
      end
    end
  end)
  
  while getgenv().DetectSpam do task.wait()
    local Ball = Balls:FindFirstChildOfClass("Part")
    local plrRP = get_plrRP()
    local ProxyPlayer = get_ProxyPlayer()
    
    if not Ball then
      getgenv().SpamClickA = false
    end
  
    if Ball and Ball:GetAttribute("realBall") and OldBall ~= Ball then
    
      Ball.Changed:Connect(function()task.wait()
        local Ball = Balls:FindFirstChildOfClass("Part")
        
        if Ball then
          TargetPlayer = Ball:GetAttribute("target")
          
          if ProxyPlayer and TargetPlayer == ProxyPlayer.Name or get_plr() and TargetPlayer == get_plr().Name then
            SpamNum = SpamNum + 1
          else
            SpamNum = 0
          end
          
          local args = ProxyPlayer and ProxyPlayer:FindFirstChild("HumanoidRootPart")
          local HL1 = ProxyPlayer and ProxyPlayer:FindFirstChild("Highlight")
          local HL2 = get_plrChar() and get_plrChar():FindFirstChild("Highlight")
          
          if plrRP and HL1 and args or plrRP and HL2 and args then
            local DistancePlayer = (ProxyPlayer.HumanoidRootPart.Position - plrRP.Position).Magnitude
            local DistanceBall = (Ball.Position - plrRP.Position).Magnitude
            
            if get_PlayersNumber() < 3 then
              if DistancePlayer <= 30 and DistanceBall <= 35 and SpamNum >= 2 then
                getgenv().SpamClickA = true
              else
                getgenv().SpamClickA = false
              end
            else
              if DistancePlayer <= 30 and DistanceBall <= 35 and SpamNum >= 3 then
                getgenv().SpamClickA = true
              else
                getgenv().SpamClickA = false
              end
            end
          else
            getgenv().SpamClickA = false
          end
        end
      end)
      OldBall = Ball
    end
  end
end

getgenv().DetectSpam = false
DetectSpam()
--    
           
                
--[[ to prevent mishaps this linebof code of the ui starts here]]--
				

--// Services
local UserInputService = game:GetService("UserInputService");

local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/Fsploit/UI-lib/refs/heads/main/Fluentremake.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "FROSTWARE [Jungle Event dsc.gg/GetFrost]",
    SubTitle = "By fsploit",
    TabWidth = 150,
    Size = UDim2.fromOffset(500, 250),
    Acrylic = false,
    Theme = "Jungle",
    MinimizeKey = Enum.KeyCode.LeftControl
})
      
local Tabs = {
    Home = Window:AddTab({ Title = "Info", Icon = "newspaper" }),
    Main = Window:AddTab({ Title = "Combat", Icon = "shield" }),
    Visual = Window:AddTab({ Title = "Utilities", Icon = "box" }),
    Farm = Window:AddTab({ Title = "Farm", Icon = "sprout" }),
    World = Window:AddTab({ Title = "World", Icon = "cloud" }),
    Config = Window:AddTab({ Title = "Player", Icon = "user" }),
}

	local r = Tabs.Home:AddSection("Information")
				    
Tabs.Home:AddParagraph({
        Title = "FROSTWARE",
        Content = [[Welcome to Frostwarebh!
    - Fixed Parry
    - Fixed Spam
    - Fixed Manual Spam
    - Anti cheat Bypassed
    - adeded Farm
    - Fixed Lag
    - Fixed System
    - Removed 3 other parrt
    ]]
})
        
Tabs.Home:AddParagraph({
        Title = "FROSTWARE",
        Content = [[This Script was Made By Fsploit!]]
})
        
local qr = Tabs.Main:AddSection("Main")
				          
local Toggle = Tabs.Main:AddToggle("Config", {Title = "Auto Parry", Description = "Parrys the ball with pre-cision", Default = false })
Toggle:OnChanged(function(state)  
    auto_curve = state        
    aura_Enabled = state
end)  
      
local Toggle = Tabs.Main:AddToggle("Config", {Title = "Auto Spam", Description = "Spams the ball within the given range.", Default = false })
Toggle:OnChanged(function(state) 
getgenv().AutoSpam = state
getgenv().DetectSpam = state
    auto_spam = state
end)
        
Tabs.Main:AddButton({
        Title = "Manual spam",
        Description = "Spams the ball thru Gui",
        Callback = function()
    --[=[
 d888b  db    db d888888b      .d888b.      db      db    db  .d8b.  
88' Y8b 88    88   `88'        VP  `8D      88      88    88 d8' `8b 
88      88    88    88            odD'      88      88    88 88ooo88 
88  ooo 88    88    88          .88'        88      88    88 88~~~88 
88. ~8~ 88b  d88   .88.        j88.         88booo. 88b  d88 88   88    @uniquadev
 Y888P  ~Y8888P' Y888888P      888888D      Y88888P ~Y8888P' YP   YP  CONVERTER 
]=]

local Spam = false  -- Set this to true to start spamming, false to stop
local spamDelay = 0.001  -- Delay between mouse events

-- Spam loop function that will run continuously while Spam is true
function spamLoop()
    while Spam do
        -- Send mouse button press and release events
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, spamDelay)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, spamDelay)
        wait(spamDelay)  -- Wait before sending the next event
    end
end

-- Start spamming immediately if Spam is true

            
-- Instances: 15 | Scripts: 2 | Modules: 0 | Tags: 0
local G2L = {};

-- StarterGui.maunalSpam
G2L["1"] = Instance.new("ScreenGui", game:GetService("RunService"):IsStudio() and game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui") or game.CoreGui);
G2L["1"]["IgnoreGuiInset"] = true;
G2L["1"]["ScreenInsets"] = Enum.ScreenInsets.DeviceSafeInsets;
G2L["1"]["Name"] = [[maunalSpam]];
G2L["1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling;
G2L["1"]["ResetOnSpawn"] = false;


-- StarterGui.maunalSpam.MainFrame
G2L["2"] = Instance.new("Frame", G2L["1"]);
G2L["2"]["BorderSizePixel"] = 0;
G2L["2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["2"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["2"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["2"]["Name"] = [[MainFrame]];
G2L["2"]["BackgroundTransparency"] = 1;


-- StarterGui.maunalSpam.MainFrame.manualSpam
G2L["3"] = Instance.new("Frame", G2L["2"]);
G2L["3"]["BorderSizePixel"] = 0;
G2L["3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3"]["Size"] = UDim2.new(0.17922, 0, 0.24153, 0);
G2L["3"]["Position"] = UDim2.new(0.41004, 0, 0.37941, 0);
G2L["3"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["3"]["Name"] = [[manualSpam]];


-- StarterGui.maunalSpam.MainFrame.manualSpam.UICorner
G2L["4"] = Instance.new("UICorner", G2L["3"]);



-- StarterGui.maunalSpam.MainFrame.manualSpam.DropShadowHolder
G2L["5"] = Instance.new("Frame", G2L["3"]);
G2L["5"]["ZIndex"] = 0;
G2L["5"]["BorderSizePixel"] = 0;
G2L["5"]["Size"] = UDim2.new(1, 0, 1, 0);
G2L["5"]["Name"] = [[DropShadowHolder]];
G2L["5"]["BackgroundTransparency"] = 1;

-- StarterGui.maunalSpam.MainFrame.manualSpam.DropShadowHolder.DropShadow
G2L["6"] = Instance.new("ImageLabel", G2L["5"]);
G2L["6"]["ZIndex"] = 0;
G2L["6"]["BorderSizePixel"] = 0;
G2L["6"]["SliceCenter"] = Rect.new(49, 49, 450, 450);
G2L["6"]["ScaleType"] = Enum.ScaleType.Slice;
G2L["6"]["ImageTransparency"] = 0.5;
G2L["6"]["ImageColor3"] = Color3.fromRGB(0, 0, 0);
G2L["6"]["AnchorPoint"] = Vector2.new(0.5, 0.5);
G2L["6"]["Image"] = [[rbxassetid://6014261993]];
G2L["6"]["Size"] = UDim2.new(1, 47, 1, 47);
G2L["6"]["BackgroundTransparency"] = 1;
G2L["6"]["Name"] = [[DropShadow]];
G2L["6"]["Position"] = UDim2.new(0.5, 0, 0.5, 0);

-- StarterGui.maunalSpam.MainFrame.manualSpam.TextLabel
G2L["7"] = Instance.new("TextLabel", G2L["3"]);
G2L["7"]["TextWrapped"] = true;
G2L["7"]["BorderSizePixel"] = 0;
G2L["7"]["TextXAlignment"] = Enum.TextXAlignment.Left;
G2L["7"]["TextScaled"] = true;
G2L["7"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7"]["TextSize"] = 14;
G2L["7"]["FontFace"] = Font.new([[rbxassetid://11702779517]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["7"]["TextColor3"] = Color3.fromRGB(255, 255, 255);
G2L["7"]["BackgroundTransparency"] = 1;
G2L["7"]["Size"] = UDim2.new(0.74319, 0, 0.10366, 0);
G2L["7"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["7"]["Text"] = [[frostware]];
G2L["7"]["Position"] = UDim2.new(0.03502, 0, 0, 0);

-- StarterGui.maunalSpam.MainFrame.manualSpam.TextButton
G2L["8"] = Instance.new("TextButton", G2L["3"]);
G2L["8"]["BorderSizePixel"] = 0;
G2L["8"]["TextTransparency"] = 1;
G2L["8"]["TextSize"] = 14;
G2L["8"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["8"]["FontFace"] = Font.new([[rbxasset://fonts/families/SourceSansPro.json]], Enum.FontWeight.Regular, Enum.FontStyle.Normal);
G2L["8"]["Size"] = UDim2.new(0.92607, 0, 0.73171, 0);
G2L["8"]["BackgroundTransparency"] = 1;
G2L["8"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["8"]["Position"] = UDim2.new(0.03502, 0, 0.17683, 0);


-- StarterGui.maunalSpam.MainFrame.manualSpam.TextButton.ON
G2L["9"] = Instance.new("TextLabel", G2L["8"]);
G2L["9"]["TextWrapped"] = true;
G2L["9"]["BorderSizePixel"] = 0;
G2L["9"]["TextTransparency"] = 1;
G2L["9"]["TextScaled"] = true;
G2L["9"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["9"]["TextSize"] = 14;
G2L["9"]["FontFace"] = Font.new([[rbxassetid://11702779517]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["9"]["TextColor3"] = Color3.fromRGB(0, 255, 0);
G2L["9"]["BackgroundTransparency"] = 1;
G2L["9"]["Size"] = UDim2.new(1, 0, 0.575, 0);
G2L["9"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["9"]["Text"] = [[ON]];
G2L["9"]["Name"] = [[ON]];
G2L["9"]["Position"] = UDim2.new(0, 0, 0.15, 0);


-- StarterGui.maunalSpam.MainFrame.manualSpam.TextButton.ON.UIGradient
G2L["a"] = Instance.new("UIGradient", G2L["9"]);
G2L["a"]["Rotation"] = 45;
G2L["a"]["Offset"] = Vector2.new(0, 0.3);
G2L["a"]["Color"] = ColorSequence.new{ColorSequenceKeypoint.new(0.000, Color3.fromRGB(255, 255, 255)),ColorSequenceKeypoint.new(1.000, Color3.fromRGB(101, 101, 101))};


-- StarterGui.maunalSpam.MainFrame.manualSpam.TextButton.OFF
G2L["b"] = Instance.new("TextLabel", G2L["8"]);
G2L["b"]["TextWrapped"] = true;
G2L["b"]["BorderSizePixel"] = 0;
G2L["b"]["TextScaled"] = true;
G2L["b"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
G2L["b"]["TextSize"] = 14;
G2L["b"]["FontFace"] = Font.new([[rbxassetid://11702779517]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
G2L["b"]["TextColor3"] = Color3.fromRGB(255, 0, 0);
G2L["b"]["BackgroundTransparency"] = 1;
G2L["b"]["MaxVisibleGraphemes"] = 6;
G2L["b"]["Size"] = UDim2.new(1, 0, 0.575, 0);
G2L["b"]["BorderColor3"] = Color3.fromRGB(0, 0, 0);
G2L["b"]["Text"] = [[OFF]];
G2L["b"]["Name"] = [[OFF]];
G2L["b"]["Position"] = UDim2.new(0, 0, 0.15, 0);


-- StarterGui.maunalSpam.MainFrame.manualSpam.TextButton.OFF.UIGradient
G2L["c"] = Instance.new("UIGradient", G2L["b"]);
G2L["c"]["Rotation"] = 45;
G2L["c"]["Offset"] = Vector2.new(0, 0.3);
G2L["c"]["Color"] = ColorSequence.new{ColorSequenceKeypoint.new(0.000, Color3.fromRGB(255, 255, 255)),ColorSequenceKeypoint.new(1.000, Color3.fromRGB(101, 101, 101))};


-- StarterGui.maunalSpam.MainFrame.manualSpam.TextButton.LocalScript
G2L["d"] = Instance.new("LocalScript", G2L["8"]);



-- StarterGui.maunalSpam.MainFrame.manualSpam.LocalScript
G2L["e"] = Instance.new("LocalScript", G2L["3"]);



-- StarterGui.maunalSpam.MainFrame.manualSpam.UIAspectRatioConstraint
G2L["f"] = Instance.new("UIAspectRatioConstraint", G2L["3"]);
G2L["f"]["AspectRatio"] = 1.56489;


-- StarterGui.maunalSpam.MainFrame.manualSpam.TextButton.LocalScript
local function C_d()
local script = G2L["d"];
	local on = false
	
	
	local tweenService = game:GetService("TweenService")
	
	function Tween(object, goal,tweenInfo, callback)
		local tween = tweenService:Create(object, tweenInfo, goal)
		tween.Completed:Connect(callback or function() end)
		tween:Play()
	end
	
	local Services = {game:GetService("AdService"), game:GetService("SocialService")}
	
	local originalParryRemote = nil
	
	function resolve_parry_Remote()
		for _, value in Services do
			local temp_remote = value:FindFirstChildOfClass("RemoteEvent")
			if temp_remote and temp_remote.Name:find("\n") then
				originalParryRemote = temp_remote
				break
			end
		end
	end
	
	local camera = workspace.CurrentCamera
	local mouse = game.Players.LocalPlayer:GetMouse()
	
	local function getClosestEntity()
		local closest_Entity = nil
		local shortestDistance = math.huge
	
		for _, entity in pairs(workspace.Alive:GetChildren()) do
			if entity:IsA("Model") and entity:FindFirstChild("HumanoidRootPart") then
				local screenPoint = camera:WorldToViewportPoint(entity.HumanoidRootPart.Position)
				local distanceToMouse = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
	
				if distanceToMouse < shortestDistance then
					closest_Entity = entity
					shortestDistance = distanceToMouse
				end
			end
		end
	
		return closest_Entity
	end
	
	script.Parent.MouseButton1Click:Connect(function()
		on = not on
		
		if on then
			Tween(script.Parent.ON,{TextTransparency = 0},TweenInfo.new(0.5,Enum.EasingStyle.Exponential,Enum.EasingDirection.Out))
			Tween(script.Parent.OFF,{TextTransparency = 1},TweenInfo.new(0.5,Enum.EasingStyle.Exponential,Enum.EasingDirection.Out))
 Spam = true
print("Spamming started.")
coroutine.wrap(spamLoop)()  
				 else
			Tween(script.Parent.ON,{TextTransparency = 1},TweenInfo.new(0.5,Enum.EasingStyle.Exponential,Enum.EasingDirection.Out))
			Tween(script.Parent.OFF,{TextTransparency = 0},TweenInfo.new(0.5,Enum.EasingStyle.Exponential,Enum.EasingDirection.Out))
		Spam = false
print("Spamming stopped.")  
		end
	end)
end;
task.spawn(C_d);
-- StarterGui.maunalSpam.MainFrame.manualSpam.LocalScript
local function C_e()
local script = G2L["e"];
	local UserInputService = game:GetService("UserInputService")
	
	local gui = script.Parent
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		local newPosition = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	
		-- Ã Â¹ÆÃ Â¸Å Ã Â¹â° Tween Ã Â¹â¬Ã Â¸Å¾Ã Â¸Â·Ã Â¹ËÃ Â¸Â­Ã Â¹ÆÃ Â¸Â«Ã Â¹â°Ã Â¸ÂÃ Â¸Â²Ã Â¸Â£Ã Â¹â¬Ã Â¸âÃ Â¸Â¥Ã Â¸Â·Ã Â¹ËÃ Â¸Â­Ã Â¸â¢Ã Â¸âÃ Â¸ÂµÃ Â¹ËÃ Â¸âÃ Â¸Â­Ã Â¸â¡ Frame Ã Â¹â¬Ã Â¸âºÃ Â¹â¡Ã Â¸â¢Ã Â¹âÃ Â¸âºÃ Â¸Â­Ã Â¸Â¢Ã Â¹ËÃ Â¸Â²Ã Â¸â¡Ã Â¸Â£Ã Â¸Â²Ã Â¸Å¡Ã Â¸Â£Ã Â¸Â·Ã Â¹ËÃ Â¸â¢
		local TweenService = game:GetService("TweenService")
		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local tween = TweenService:Create(gui, tweenInfo, {Position = newPosition})
		tween:Play()
	end
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			update(input)
		end
	end)
	
end;
task.spawn(C_e);

return G2L["1"], require;
    
end})
        
        
Tabs.Main:AddButton({
        Title = "PC Spam",
        Description = "Press 'E' to toggle the spam for pc.",
        Callback = function()
Fluent:Notify({
    Title = "FROSTWARE",
    Content = "Executed. please note your keybind spam is E",
    Duration = 10
})
local activatedD = false
local VirtualInputManager = game:GetService("VirtualInputManager")
local function toggle()
    activatedD = not activatedD -- Toggle the activated state
    while activatedD do
        -- Fire the mouse button events
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)  -- Mouse Down
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001) -- Mouse Up
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)  -- Mouse Down
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001) -- Mouse Up
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)  -- Mouse Down
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001) -- Mouse Up
        -- Wait for the next cycle (adjust delay if needed)
        game:GetService("RunService").Heartbeat:Wait()
    end
end
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if input.KeyCode == Enum.KeyCode.E and not gameProcessedEvent then
        toggle()
    end
end)
end})
        
Tabs.Main:AddButton({
    Title = "PC Spam",
    Description = "Press and hold 'R' to spam for PC.",
    Callback = function()
        Fluent:Notify({
            Title = "FROSTWARE",
            Content = "Executed. Hold 'R' to spam.",
            Duration = 10
        })

        local holdingR = false
        local VirtualInputManager = game:GetService("VirtualInputManager")

        -- Function to handle spamming while the key is held
        local function spam()
            while holdingR do
                -- Fire the mouse button events
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)  -- Mouse Down
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0.001) -- Mouse Up
                game:GetService("RunService").Heartbeat:Wait() -- Adjust delay if needed
            end
        end

        local UserInputService = game:GetService("UserInputService")

        -- Detect when 'R' is pressed
        UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
            if input.KeyCode == Enum.KeyCode.R and not gameProcessedEvent then
                holdingR = true
                task.spawn(spam) -- Start spamming in a separate thread
            end
        end)

        -- Detect when 'R' is released
        UserInputService.InputEnded:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.R then
                holdingR = false -- Stop spamming
            end
        end)
end})


local AAAA = Tabs.Visual:AddSection("Utilitys")		    
				    
local Toggle = AAAA:AddToggle("Visualize", {Title = "View Part", Description = "Visualize The Auto Parry [best for debug]", Default = false })
Toggle:OnChanged(function(v)
        visualize_Enabled = v
	end)			      				
        
    
				    
local Toggle = AAAA:AddToggle("Nightmode", {Title = "View ball velocity", Description = "Views the ball speed [Best for Debug]", Default = false })
Toggle:OnChanged(function(v)
	BallVelocity = v
	end)
        
        

local Hake = Tabs.Farm:AddSection("Farms")		    

local Dropdown = Hake:AddDropdown("Dropdown", {
        Title = "Farm Type",
        Values = {"UnderBall", "X Orbit", "Y Orbit"},
        Multi = false,
        Default = 1,
    })

    Dropdown:SetValue("UnderBall")

    Dropdown:OnChanged(function(Value)
     AutoFarmType = Value
    end)		  
				    			   
local Toggle = Hake:AddToggle("AutoCurve", {Title = "Auto Farm", Description = "Farms the ball", Default = false })
Toggle:OnChanged(function(state)
	AutoFarm = state
end)

				    
				local Slider = Hake:AddSlider("Slider", {
        Title = "Orbit Speed",
        Description = "This is for the Orbit on the farm.",
        Default = 20,
        Min = 0,
        Max = 300,
        Rounding = 1,
        Callback = function(Value)
            AutoFarmOrbit = Value 
        end
    })




local Dropdown = Hake:AddDropdown("Dropdown", {
        Title = "Ai Type",
        Values = {"Legit", "Hacker"},
        Multi = false,
        Default = 1,
    })

    Dropdown:SetValue("Legit")

    Dropdown:OnChanged(function(Value)
        AiPlayType = Value
    end)		  


local Toggle = Hake:AddToggle("AutoCurve", {Title = "Ai Play", Description = "Farms the ball by Auto playing", Default = false })
Toggle:OnChanged(function(state)
	AiPlay = state
end)



        


local Slider = Hake:AddSlider("Slider", {
        Title = "Hacker Speed",
        Description = "This is for the Hacker mode on the Ai Play.",
        Default = 20,
        Min = 0,
        Max = 300,
        Rounding = 1,
        Callback = function(Value)
            AiPlaySpeed = Value
        end
    })

 
local Wrr = Tabs.World:AddSection("World")
				    
 Wrr:AddButton({
        Title = "Fps Boost",
        Description = "Reduces Graphics and boosts your fps by alot",
        Callback = function()
                local decalsyeeted = true
local g = game
local w = g.Workspace
local l = g.Lighting
local t = w.Terrain
t.WaterWaveSize = 0
t.WaterWaveSpeed = 0
t.WaterReflectance = 0
t.WaterTransparency = 0
l.GlobalShadows = false
l.FogEnd = 9e9
l.Brightness = 0
settings().Rendering.QualityLevel = "Level01"
for i, v in pairs(g:GetDescendants()) do
    if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
    elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
        v.Transparency = 1
    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
        v.Lifetime = NumberRange.new(0)
    elseif v:IsA("Explosion") then
        v.BlastPressure = 1
        v.BlastRadius = 1
    elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") or v:IsA("Sparkles") then
        v.Enabled = false
    elseif v:IsA("MeshPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
        v.TextureID = 10385902758728957
    end
end
for i, e in pairs(l:GetChildren()) do
    if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
        e.Enabled = false
    end
end
end})
        
local Toggle = Wrr:AddToggle("Config", {Title = "Night Mode", Description = "Toggles Night Mode", Default = false })
Toggle:OnChanged(function(state)  
    Nightmode = state 
end) 
        
local Toggle = Wrr:AddToggle("Config", {Title = "Shaders", Description = "Toggles Shaders", Default = true })
Toggle:OnChanged(function(state)  
    ShadersEffect = state  
end) 
        
        

 
            
	
local DDDD = Tabs.Config:AddSection("Player")
				    
local Slider = DDDD:AddSlider("Slider", {
        Title = "Walk speed",
        Description = "Edits the players walkspeed",
        Default = 30,
        Min = 0,
        Max = 500,
        Rounding = 1,
        Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
print("Hi")
        end
    })
  local Slider = DDDD:AddSlider("Slider", {
        Title = "Jump power",
        Description = "Edits The player Jump Power",
        Default = 40,
        Min = 0,
        Max = 500,
        Rounding = 1,
        Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
print("Hi")
        end
    })
  local Slider = DDDD:AddSlider("Slider", {
        Title = "FOV",
        Description = "Edits the Camera Field of View [FOV]",
        Default = 70,
        Min = 0,
        Max = 500,
        Rounding = 1,
        Callback = function(Value)
            local FovNumber = Value
local Camera = workspace.CurrentCamera
Camera.FieldOfView = FovNumber
print("Hi")
        end
    })
  local Slider = DDDD:AddSlider("Slider", {
        Title = "Gravity",
        Description = "Edits your Gravity",
        Default = 197,
        Min = 0,
        Max = 500,
        Rounding = 1,
        Callback = function(Value)
            workspace.Gravity = Value
print("edit by ikorz or kiolaz or the cat fornite")
        end
    })

        
        
